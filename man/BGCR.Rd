% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BGCR.R
\name{BGCR}
\alias{BGCR}
\title{Bayesian Graphical Compositional Regression}
\usage{
BGCR(formula, data, PrJAP = 0.5, sum_PrMAP = "default",
  threshold = 0.005, kappa = 0, nu = 10^(seq(-1, 4)), sigma = 4,
  verbose = FALSE)
}
\arguments{
\item{formula}{a one-sided formula that describes the covariates need to be adjusted.}

\item{data}{a phyloseq object containing the otu table, the covariates and the phylogenetic tree. In the OTU table, taxa are rows. The covariate table must contain a grouping variable named "group", with factor levels 0 and 1.}

\item{PrJAP}{a value between 0 and 1. The prior joint alternative probability used for choosing \eqn{\alpha}.}

\item{sum_PrMAP}{a positive value less than the total number of internal nodes in the phylogenetic tree. The sum of prior marginal alternative probability used for choosing \eqn{\tau}. The default value is set to 2, recommended for 100 OTUs.}

\item{threshold}{a positive value controls the accuracy used for the empirical Bayes estimate of \eqn{\tau}.}

\item{kappa}{a non-negative value controls the chaining pattern will occur along the phylogenetic tree. The default value 0 introduces an explaning away effect.}

\item{nu}{a vector contains a sequence of the dispersion parameter \eqn{\nu} used for numerically computing the marginal likelihood.}

\item{sigma}{a positive value. The standard deviation of the normal prior on the regression coefficient.}

\item{verbose}{logicals. If true, print the number of internal node processed while computing the marginal likelihoods.}
}
\value{
\code{BGCR} returns an object of class \code{"BGCR"}. A \code{"BGCR"} object is a list containing the following components:
 \itemize{
  \item \code{tree} - the phylogenetic tree. An object of class \code{"phylo"} containing the phylogenetic information of the OTUs.
  \item \code{PJAP} - the posterior joint alternative probability.
  \item \code{PMAP} - a vector containing the posterior marginal alternative probability at each internal node of the phylogenetic tree, ordered according to the label of the node in the phylogenetic tree. Note that the first half of the vector contains zeros since they represent the leaves of the tree.
  \item \code{PJAP_ind} - the posterior joint alternative probability returned by BCR, similar to \code{PJAP}.
  \item \code{PMAP_ind} - the posterior marginal alternative probabilities returned by BCR, similar to \code{PMAP}.
  \item \code{BF} - a vector containing the Bayes factor comparing the local hypotheses at each internal node. The orders are same as the orders in \code{PMAP}.
  \item \code{alpha} - the value of \eqn{\alpha} used for BGCR.
  \item \code{tau} - the value of \eqn{\tau} used for BGCR estimated by the empirical Bayes procedure.
}
}
\description{
Fit the Bayesian Graphical Compositional Regression for comparing two groups of microbiome count data.
}
\examples{
library(ape)
library(phyloseq)

#create a phyloseq object (https://joey711.github.io/phyloseq/import-data.html).

otumat = matrix(sample(1:100, 100, replace = TRUE), nrow = 10, ncol = 10)
rownames(otumat) <- paste0("OTU", 1:nrow(otumat))
colnames(otumat) <- paste0("Sample", 1:ncol(otumat))

taxmat = matrix(sample(letters, 70, replace = TRUE), nrow = nrow(otumat), ncol = 7)
rownames(taxmat) <- rownames(otumat)
colnames(taxmat) <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species")

OTU = otu_table(otumat, taxa_are_rows = TRUE)
TAX = tax_table(taxmat)
sampledata = sample_data(data.frame(
  group = factor(c(rep(0, 4), rep(1, 6))),
  Location = factor(sample(c(0,1), size=nsamples(physeq), replace=TRUE)),
  Depth = sample(50:1000, size=nsamples(physeq), replace=TRUE),
  row.names=sample_names(physeq),
  stringsAsFactors=FALSE
))

random_tree = rtree(ntaxa(physeq), rooted=TRUE, tip.label=taxa_names(physeq))

data = phyloseq(OTU, TAX, sampledata, random_tree)

#run BGCR, first adjusting for no covariate
result <- BGCR(~group, data)

#run BGCR, adjusting for some covariate
result <- BGCR(~group + Location + Depth, data)

plot(x = result)

}
